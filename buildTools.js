var os = require('os');
var fs = require('fs');
var path = require('path');
var child_process = require('child_process');

var options = 
{
	verbose: false,
	clean: false,
	files: [],
	switches: {},
	//companyName: "",
	//codeSignCertificate: "",
	//codeSignPasswordFile: "",
	//symStorePath: "",
};


// Check command line args
for (var i=0; i<process.argv.length; i++)
{
	var a = process.argv[i];


	var isSwitch = false;
	if (a.startsWith("--"))
	{
		isSwitch = true;
		a = a.substring(2);
	}
	else if (a.startsWith("/"))
	{
		isSwitch = true;
		a = a.substring(1);
	}

	if (isSwitch)
	{
		var parts = a.split(':');
		if (parts.length == 2)
		{
			if (parts[1]=='false' || parts[1]=='no')
				options.switches[parts[0]] = false;
			else
				options.switches[parts[0]] = parts[1];
		}
		else
		{
			options.switches[parts[0]] = true;
		}
	}
	else
	{
		options.files.push(a);
	}
}

options.verbose = options.switches.verbose;
options.clean = options.switches.clean;
options.official = options.switches.official;
options.nuget = options.switches.nuget;


function version()
{
	// Load the version info
	var verInfo = JSON.parse(fs.readFileSync("version.json", 'UTF8'));
	console.log(`${verInfo.productName} v${verInfo.major}.${verInfo.minor}.${verInfo.build}`);

	options.version = verInfo;
}

function clock_version()
{
	var verInfo = options.version;
	var newBuild = prompt(`Enter new build number, 'n' to keep current, or enter to bump to ${verInfo.build+1}:`);
	if (newBuild != "n")
		verInfo.build = newBuild ? parseInt(newBuild) : verInfo.build + 1;
	fs.writeFileSync("version.json", JSON.stringify(verInfo, null, 4), 'UTF8');

	// Work out copyright year range
	var now = new Date();
	var currentYear = now.getUTCFullYear()
	var copyrightYear = currentYear == verInfo.copyrightYear ? "" + currentYear : verInfo.copyrightYear + "-" + currentYear;

	// Write version .h
	fs.writeFileSync("version.h", `
#define VER_A		${verInfo.major}
#define VER_B		${verInfo.minor}
#define VER_C		${verInfo.build}
#define VER_D		0
#define COPYRIGHT_STRING "Copyright \xA9 ${copyrightYear} ${options.companyName}. All Rights Reserved\\0"
	`, 'UTF8');

	// Write version.cs
	fs.writeFileSync("version.cs", `
// Generated by build tool, do not edit
using System;
using System.Reflection;
[assembly: AssemblyCopyright("Copyright \u00A9 ${copyrightYear} ${options.companyName}. All Rights Reserved")]
[assembly: AssemblyVersion("${verInfo.major}.${verInfo.minor}.${verInfo.build}")]
[assembly: AssemblyFileVersion("${verInfo.major}.${verInfo.minor}.${verInfo.build}")]
[assembly: AssemblyCompany("${options.companyName}")]
[assembly: AssemblyProduct("${verInfo.productName}")]

static class BuildInfo
{
	public static DateTime Date = new DateTime(${now.getUTCFullYear()}, ${now.getUTCMonth()+1}, ${now.getUTCDate()}, ${now.getUTCHours()}, ${now.getUTCMinutes()}, ${now.getUTCSeconds()}, DateTimeKind.Utc);
}
	`, 'UTF8');

	fs.writeFileSync("version.props", `
<!-- Generated by build tool, do not edit -->
<Project>
  <PropertyGroup>
  	<Version Condition="'$(Variable)' == ''">${verInfo.major}.${verInfo.minor}.${verInfo.build}</Version>
  </PropertyGroup>
</Project>	
	`, 'UTF8');


}

function clean(folder)
{
	if (options.clean && fs.existsSync(folder))
	{
		// Build a Visual Studio project
		console.log(`Cleaning ${folder}...`);
		rmdir(folder);
	}
}

function git_check_internal(folder)
{
	var opts = { encoding: 'UTF8' };

	if (folder)
	{
		opts.cwd = folder
	}

	if (!folder)
		folder = '.';

	// Call git status
	var r = child_process.spawnSync("git", ["status"], opts);

	// Check success
	if (r.status != 0)
	{
		console.log(r.stdout);
		console.log("Failed to check git status");
		return false;
	}

	// Check clean
	if (!r.stdout.match(/nothing to commit, working tree clean/gi))
	{
		console.log(r.stdout);
		console.log("Working directory not clean, aborting!")
		return false;
	}

	// Get branch name
	var m = /^On branch (.*)/g.exec(r.stdout);
	console.log(`${folder} => ${m[1]}`);

	return true;
}

function git_check(folder)
{
	if (options.switches.nogit)
		return;

	if (!git_check_internal(folder))
		process.exit(7);
}

function git_tag(folder)
{
	if (options.switches.nogit)
		return;

	var tag = `b${options.version.major}.${options.version.minor}.${options.version.build}`;
	console.log(`Tagging ${folder ? folder : '.'} as ${tag}`)

	run("git", [
		"add", "."
	], folder);

	run("git", [
		"commit", "-m", tag, "--allow-empty"
	], folder);

	run("git", [
		"tag", "-f", tag
	], folder);

	run("git", [
		"push", "--quiet"
	], folder);

	run("git", [
		"push", "-f", "--tags", "--quiet"
	], folder);
}

function msbuild(sln, proj, platform, config)
{
	console.log(`Building ${proj} (${config}|${platform})`);

	if (proj != "*")
	{
		invoke_msbuild([
			sln, 
			`/t:${proj.replace(/\./g, '_')}`,
			`/p:Configuration=${config}`,
            `/p:Platform=${platform}`, 
			`/verbosity:minimal`
			]);
	}
	else
	{
		invoke_msbuild([
			sln, 
			`/p:Configuration=${config}`,
			`/p:Platform=${platform}`,
			`/verbosity:minimal`
			]);
	}
}

// Invoke msbuild
function invoke_msbuild(args)
{
	run("C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\MSBuild\\15.0\\bin\\msbuild.exe", args);
}

function vsbuild(sln, proj, platform, config)
{
	console.log(`Building ${proj} (${config}|${platform})`);
	invoke_devenv([
		sln, 
		"/build", config + "|" + platform,
		"/project", proj
		]);
}

// Invoke devenv
function invoke_devenv(args)
{
	run("C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\IDE\\DevEnv.com", args);
}

function dnbuild(config, project)
{
	console.log(`Building with dotnet (${config})`);
	
	var args = ["build", "-c", config];
	if (project)
		args.push(project);

	run("dotnet", args);
}

function dnpack(config, project, framework)
{
	console.log(`Packing with dotnet (${config})`);
	
	var args = ["pack", "-c", config];

	if (framework)
		args.push("-p:TargetFrameworks=" + framework);
		
	if (project)
		args.push(project);

	run("dotnet", args);
}

function dntest(config, project)
{
	console.log(`Running tests... (${config})`);

	var args = ["test", "-c", config];
	if (project)
		args.push(project);

	run("dotnet", args);
}

// Obfuscate an assembly and place it in a subfolder "obfuscated"
function obfuscate(filename, outFolder)
{
	console.log("");

	if (!outFolder)
		outFolder = path.join(path.dirname(filename), "obfuscated");
	mkdirp(outFolder);

	run("C:\\Program Files (x86)\\Eazfuscator.NET\\eazfuscator.net.exe",
	[
		filename,
		"-o", path.join(outFolder, path.basename(filename))
	]);
}

// Build nuget package
function nupack(nuspec, outputFolder)
{
	console.log("");
	console.log(`Building nuget package - ${nuspec}`);
	run("nuget", [
		"pack",
		nuspec,
		"-Version", `${options.version.major}.${options.version.minor}.${options.version.build}`,
		"-OutputDirectory", outputFolder
	]);
}

// Publish nuget package
function nupush(nupkg, server)
{
	var args = [
		"push",
		fixPathForOs(nupkg),
		"-Timeout", "600"
	]

	if (server)
	{
		args.push("-Source");
		args.push(server);
	}

	console.log("");
	console.log(`Publish nuget package(s) - ${nupkg} to ${server}`);
	run("nuget", args);
}

// Run inno setup
function inno(filename)
{
	console.log("")
	console.log(`Building setup - ${filename}`);
	run("C:\\Program Files (x86)\\Inno Setup 5\\iscc.exe", [
		"/dBuildNumber=" + options.version.build,
		"/dVersionNumber=" + options.version.major + "." + options.version.minor,
		filename
	]);
}

function editbin(filename, args)
{
	args.push(filename);
	args.push("/NOLOGO");
	run("C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.11.25503\\bin\\Hostx64\\x64\\editbin", args);
}

// Sign a file
function signfile(filename, description)
{
	if (!Array.isArray(filename))
		filename = [ filename ];

	console.log("");
	console.log(`Signing ${filename.length} file(s)...`);
	var password = fs.readFileSync(options.codeSignPasswordFile, 'UTF8').trim();

	var args = 	[
		"sign",
		"/fd", "sha1",
		"/t", "http://timestamp.comodoca.com/authenticode",
		"/f", options.codeSignCertificate,
		"/p", password,
		"/d", description,
	];

	args = args.concat(filename);

	run(path.join(__dirname, "signtool.exe"), args);
}

// Store symbols
function symstore(filespec)
{
	run(path.join(__dirname, "symstore.exe"), [
		"add", "/r", "/f",
		filespec,
		"/s", options.symStorePath,
		"/t", `${options.version.productName} ${options.version.major}.${options.version.minor}`,
		"/v", `Build ${options.version.build}`
	]);
}


function copy(from, to)
{
	console.log("");
	run("xcopy.exe", [
		"/Y",
		from,
		to
	]);
}

function copyDir(from, to)
{
	console.log("");
	run("xcopy.exe", [
		"/Y", "/S",
		from,
		to
	]);
}

function fixPathForOs(path)
{
	if (os.platform() == "win32")
		return path.replace(/\//g, '\\');
	else
		return path.replace(/\\/g, '/');
}

// Run a command
function run(cmd, args, cwd)
{
	function escapeArg(x)  
	{
	    if (os.platform() == "win32")
	        return (x.indexOf(' ') >= 0 || x.indexOf('|') >= 0)? `"${x}"` : x;
	    else
	        return x.replace(/ /g, '\\ ');
	}

	if (!args)
		args = [];

    if (options.verbose)
    {
        console.log(escapeArg(cmd), args.map(escapeArg).join(" "));
    }

    var opts = {
    	stdio: 'inherit'
    }

    if (cwd)
    	opts.cwd = cwd;

    var r = child_process.spawnSync(cmd, args.map(fixPathForOs), opts);

    // Failed to launch
    if (r.error)
    {
		if (!options.verbose)
		{
			console.log("\n\n");
			console.log(escapeArg(cmd), args.map(escapeArg).join(" "));
		}
		console.log("\nFailed", r.error.message);
		process.exit(7);
    }

    // Failed exit code?
	if (r.status != 0)
	{
		if (!options.verbose)
		{
			console.log("\n\n");
			console.log(escapeArg(cmd), args.map(escapeArg).join(" "));
		}
		console.log("\nFailed with exit code", r.status);
		process.exit(7);
	}
}

function parseArgs(cmd)
{
	// Already an array?
	if (Array.isArray(cmd))
		return cmd;

	// Split command
	let args = [];
	let arg = "";
	let inQuote = false;
	for (var i=0; i<cmd.length; i++)
	{
		if (cmd[i] == '\"')
		{
			if (inQuote)
			{
				inQuote = false;
			}
			else
			{
				inQuote = true;
			}
			continue;
		}

		if (!inQuote && cmd[i] == ' ' || cmd[i] == '\t')
		{
			if (arg.length > 0)
			{
				args.push(arg);
				arg = "";
			}
		}
		else
		{
			arg += cmd[i];
		}
	}

	if (arg.length > 0)
		args.push(arg);

	return args;
}

var _cli_cwd;

// Set cwd for the next cli command
function cli_cwd(cwd)
{
	_cli_cwd = cwd;
}

// Arguments to the function can be:
// 1. Space separated strings using double quotes for spaces
// 2. An array (which won't be parsed at all)
// All parse args are concatenated, first is used as command
// To change cwd, use the cli_cwd command above
function cli()
{
	// Parse args
	var args = [];
	for (var i = 0; i < arguments.length; i++) 
	{
		args = args.concat(parseArgs(arguments[i]));
	}

	// First arg is the command
	var cmd = args.shift();

	// Run the command
	var ret = run(cmd, args, _cli_cwd);

	// Clear the cwd
	_cli_cwd = null;
	return ret;
}

function getEnv(name, defVal)
{
    if (process.env[name])
        return process.env[name];
    else
        return defVal;
}

function rmdir(folder) 
{
	if (options.verbose)
	{
		console.log("Removing directory", folder);
	}
	rmdirI(folder);
}

function rmdirI(folder) 
{
    if (fs.existsSync(folder)) 
    {
        fs.readdirSync(folder).forEach(function(file,index)
        {
            var curPath = path.join(folder, file);
            if(fs.lstatSync(curPath).isDirectory()) 
            { 
                rmdirI	(curPath);
            } 
            else 
            { 
                fs.unlinkSync(curPath);
            }
        });

        fs.rmdirSync(folder);
    }
};

function mkdirp(targetDir)
{
    const sep = path.sep;
    const initDir = path.isAbsolute(targetDir) ? sep : '';
    targetDir.split(sep).reduce((parentDir, childDir) => {
      const curDir = path.resolve(parentDir, childDir);
      if (!fs.existsSync(curDir)) {
        fs.mkdirSync(curDir);
      }

      return curDir;
    }, initDir);
}

// Hacky, but dependency free way to prompt for a string
function prompt(message)
{
	// Generate a script
	var scriptFile = path.join(process.env["TEMP"], "prompt.bat");
	var responseFile = path.join(process.env["TEMP"], "response.txt");
	var script = `@echo off\r\nset /p response= \"${message}\"\r\nIF "%response%"=="" (ECHO. > ${responseFile} ) ELSE (ECHO %response% > ${responseFile})\r\n`;
	fs.writeFileSync(scriptFile, script, 'UTF8');

	// Delete response file
	if (fs.existsSync(responseFile))
		fs.unlinkSync(responseFile);

	// Run it
    child_process.spawnSync(scriptFile, [], { stdio: 'inherit', shell: true });

	var response;
	if (fs.existsSync(responseFile))
	{
		response = fs.readFileSync(responseFile, 'UTF8');
		fs.unlinkSync(responseFile);
	}

	fs.unlinkSync(scriptFile);

	return response.trim();
}


function upload(localfile, remotefile, chmod)
{
	run("c:\\cygwin64\\bin\\scp", [
		localfile,
		remotefile
	]);

	if (chmod)
	{
		var parts = remotefile.split(':');
		run("c:\\cygwin64\\bin\\ssh", [
			parts[0],
			"chmod", chmod, parts[1]
		]);
	}

}

function open_url(url)
{
	run("cmd.exe", [
		"/C", "start", url
	])
}

function validate_json(filename)
{
	try
	{
		JSON.parse(fs.readFileSync(filename, 'UTF8'))	
	}
	catch (err)
	{
		console.log(`JSON error in file ${filename}.`, err.message);
		process.exit(7);
	}

}

module.exports = {
	options: options,
	version: version,
	clock_version: clock_version,
	clean: clean,
	git_check: git_check,
	git_tag: git_tag,
	msbuild: msbuild,	
	vsbuild: vsbuild,	
	dnbuild: dnbuild,
	dnpack: dnpack,
	dntest: dntest,
	invoke_devenv: invoke_devenv,
	invoke_msbuild: invoke_msbuild,
	obfuscate: obfuscate,
	nupack: nupack,
	nupush: nupush,
	inno: inno,
	signfile: signfile,
	symstore: symstore,
	editbin: editbin,
	copy: copy,
	copyDir: copyDir,
	run: run,
	cli_cwd: cli_cwd,
	cli: cli,
	rmdir: rmdir,
	mkdirp: mkdirp,
	prompt: prompt,
	upload: upload,
	open_url: open_url,
	validate_json: validate_json,
}